#!/usr/bin/env node

const util = require("util");
const fs = require("fs");
var readline = require('readline');

const parser = require("../lib/parser");

const { default: InterpreterVisitors } = require('./InterpreterVisitors');

Object.prototype.inspect = function () {
  return util.inspect(this, {
    compact: false,
    depth: Infinity
  });
};

Number.prototype.inspect = function () {
  return `${this}`;
};

String.prototype.inspect = function () {
  return `"${this}"`;
};

String.prototype['++'] = function (that) {
  return this.concat(that);
};

//

const collect = (values, mapper) => {
  return values.reduce((array, item) => {
    const result = mapper(item);

    return result ? [...array, result] : array;
  }, []);
};

const visit = (visitors, node) => {
  if (visitors[node.constructor.name]) {
    return visitors[node.constructor.name](node);
  } else {
    throw new Error(`No AST visitor for '${node.constructor.name}'`);
  }
};

const parens = (string) => {
  return `\x1b[37;2m(\x1b[0m${string}\x1b[37;2m)\x1b[0m`;
};

//

class Visitors {
  Comment({ value }) {
    return;
    return `# ${value}`;
  }

  Block({ statements }) {
    return collect(statements, statement => visit(this, statement));
  }

  ApplyExpression({ expr, args }) {
    return parens(`${visit(this, expr)} ${visit(this, args)}`);
  }

  TupleExpression({ elements }) {
    return parens(`${elements.map(value => visit(this, value)).join(', ')}`);
  }

  FunctionExpression({ params, statements }) {
    return parens(`${visit(this, params)} => ${collect(statements, statement => visit(this, statement))}`);
  }

  OperatorExpression({ op, left, right }) {
    return parens(`${visit(this, left)} ${op} ${visit(this, right)}`);
  }

  TuplePattern({ elements }) {
    return parens(`${elements.map(value => visit(this, value)).join(', ')}`);
  }

  Identifier({ name }) {
    return name;
  }
};

let buffer = '';
let inBlock = false;

if (process.argv.length === 3) {
  fs.readFile(process.argv[2], "utf8", (err, input) => {
    const ast = parser.parse(input);

    for (let statement of visit(new Visitors(), ast)) {
      console.log(statement);
    }

    let prevNode = null;

    for (let node of ast.statements) {
      const formattedAst = util.inspect(node, {
        compact: false,
        depth: Infinity
      });

      if (typeof node === 'string' && typeof prevNode !== 'string') {
        console.log();
      }

      prevNode = node;

      // console.log(formattedAst);
    }
  });
} else {
  let scope = {
    print: {
      kopiApply: (args, scope) => ({
        value: console.log(args.inspect()),
        scope
      })
    },
    set: {
      kopiApply: (args, scope) => ({
        value: {
          kopiApply: (value, scope) => ({
            value: undefined,
            scope: { ...scope, [args.name]: value }
          })
        },
        scope
      })
    },
    update: {
      kopiApply: (args, scope, visitors) => ({
        value: {
          kopiApply: (value, scope) => ({
            value: undefined,
            scope: { ...scope, [args.name]: value.kopiApply(scope[args.name], scope, visitors).value }
          })
        },
        scope
      })
    },
    match: {
      kopiApply: (value, scope, visitors) => ({
        value: {
          kopiApply: (funcs, scope) => {
            const func = funcs.values.find(func => Object.values(func.params.match(value)).length !== 0);

            return {
              value: func && func.kopiApply(value, scope, visitors).value,
              scope
            };
          }
        },
        scope
      })
    }
  };

  const visitors = new InterpreterVisitors();

  console.log('Kopi Language 0.0.1 â€“ 2021 Mike Austin');

  var rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  process.stdin.setRawMode(true);

  rl.prompt();
  rl.on('line', function (line) {
    if (inBlock) {
      if (line.match(/^\)/)) {
        buffer += '\n' + line + '\n';

        inBlock = false;
      } else {
        buffer += '\n' + line;

        return;
      }
    } else if (line.match(/\($/)) {
      inBlock = true;
      buffer += line;

      return;
    } else {
      buffer = '\n' + line;
    }

    const ast = parser.parse(buffer);

    if (!inBlock) {
      buffer = '';
    }

    try {
      const result = visitors.visit(ast.statements[0], scope);

      if (result.value !== undefined) {
        console.log(result.value.inspect());
      }

      scope = { ...scope, ...result.scope };
    } catch (error) {
      console.log(error);
    }

    rl.prompt();
  });
}
