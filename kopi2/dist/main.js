/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./bin/context.js":
/*!************************!*\
  !*** ./bin/context.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n  AnyType,\n  NoneType,\n  BooleanType,\n  NumberType,\n  StringType,\n  TupleType,\n  FunctionType,\n  UnionType,\n  ArrayType,\n} = __webpack_require__(/*! ../src/visitors/types */ \"./src/visitors/types/index.js\");\n\nconst { Function, Tuple, IdentifierPattern } = __webpack_require__(/*! ../src/visitors/classes */ \"./src/visitors/classes/index.js\");\n\nBoolean.prototype.type = BooleanType();\nNumber.prototype.type = NumberType();\nString.prototype.type = StringType();\n\nArray.prototype.valueForField = function (field) {\n  if (typeof field === 'number') {\n    return this[field] ?? new Tuple();\n  }\n};\n\nBoolean.prototype.escape = function () {\n  return `${this}`;\n};\n\nNumber.prototype.escape = function () {\n  return `${this}`;\n};\n\n// Number.prototype.toElement = function () {\n//   const node = document.createTextNode(`${this}`);\n\n//   return node;\n// };\n\nImage.prototype.toElement = function () {\n  const node = document.createElement('img');\n  // node.src = 'https://mike-austin.com/new/images/Escher_Circle_Limit_III.jpg';\n  // node.width = 100;\n  // node.height = 100;\n  console.log(this.src);\n  node.src = this.src;\n  node.width = this.width;\n  node.height = this.height;\n\n  return node;\n};\n\nString.prototype.escape = function () {\n  return `\"${this}\"`;\n};\n\nArray.prototype.escape = function () {\n  return `[${this.map(element => element.escape()).join(', ')}]`;\n};\n\nlet context = {\n  image: FunctionType(new IdentifierPattern('url', StringType()), TupleType()),\n  true: BooleanType(),\n  false: BooleanType(),\n  help: FunctionType(new IdentifierPattern('func', AnyType()), TupleType()),\n  source: FunctionType(new IdentifierPattern('func', AnyType()), TupleType()),\n  inspect: FunctionType(new IdentifierPattern('value', AnyType()), StringType()),\n  not: FunctionType(new IdentifierPattern('value', BooleanType()), BooleanType()),\n  even: FunctionType(new IdentifierPattern('value', NumberType()), BooleanType()),\n  union: FunctionType(new IdentifierPattern('value', UnionType(NumberType(), StringType())), BooleanType()),\n  print: FunctionType(new IdentifierPattern('value', AnyType()), TupleType()),\n  test: FunctionType(new IdentifierPattern('value', ArrayType(NumberType())), TupleType()),\n  _: NoneType()\n};\n\nmodule.exports = {\n  default: context\n};\n\n\n//# sourceURL=webpack://kopi2/./bin/context.js?");

/***/ }),

/***/ "./bin/scope.js":
/*!**********************!*\
  !*** ./bin/scope.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Function, Tuple, Range, IdentifierPattern } = __webpack_require__(/*! ../src/visitors/classes */ \"./src/visitors/classes/index.js\");\nconst { default: PrintCodeVisitors } = __webpack_require__(/*! ../src/visitors/PrintCodeVisitors */ \"./src/visitors/PrintCodeVisitors.js\");\n\nconst printCodeVisitors = new PrintCodeVisitors();\n\nconst doc = strings => strings[0].trim().split('\\n').map(line => line.trim()).join('\\n');\n\nlet scope = {\n  image: new class extends Function {\n    apply(arg, source, visitor) {\n      const image = new Image();\n      image.src = arg;\n\n      return image;\n    }\n  },\n  true: true,\n  false: false,\n  help: new class extends Function {\n    constructor() {\n      super();\n\n      this.help = doc`\n        Shows top-level functions available.\n      `;\n    }\n\n    escape() {\n      console.log('––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––');\n      Object.entries(scope).filter(([name, value]) => value instanceof Function).forEach(([name, value], index) => {\n        if (index > 0) console.log('\\t\\t––––––––––––––––––––––––––––––––––––––––––––––––––');\n        console.log(`${name}\\r\\t\\t${value.help?.split('\\n')[0] ?? 'No help available.'}`);\n        value.type && console.log(`\\t\\t${value.type.escape()}`);\n      });\n      console.log('––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––');\n\n      return 'Type \\'help\\' <function> for detailed help.';\n    }\n\n    apply(arg, scope, visitors) {\n      const help = arg.help?.split('\\n') ?? [];\n\n      console.log('––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––');\n      console.log(help[0] ?? 'No help available.');\n      console.log(`${arg.type.escape()}`);\n      console.log('––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––');\n      console.log(help[1] ?? 'No detailed help available.');\n      console.log('––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––');\n    }\n  },\n  source: new class extends Function {\n    apply(arg, scope, visitors) {\n      if (arg.body) {\n        console.log(printCodeVisitors.visitNode(arg));\n      } else {\n        console.log('<native function>');\n      }\n    }\n  },\n  inspect: new class extends Function {\n    apply(arg, scope, visitors) {\n      console.log(Object.prototype.inspect.apply(arg));\n    }\n  },\n  not: new class extends Function {\n    apply(arg, scope, visitors) {\n      return !arg;\n    }\n  },\n  even: new class extends Function {\n    constructor() {\n      super();\n\n      this.help = doc`\n        Returns true if number is even, else false.\n        Detailed documentation...\n      `;\n    }\n\n    apply(arg, scope, visitors) {\n      return arg % 2 === 0;\n    }\n  },\n  union: new class extends Function {\n    apply(arg, scope, visitors) {\n      return (typeof arg === 'string' ? Number(arg) : arg) % 2 === 0;\n    }\n  },\n  print: new class extends Function {\n    constructor() {\n      super();\n\n      this.help = doc`\n        Write's all arguments to the console.\n      `;\n    }\n\n    apply(arg, scope, visitors) {\n      console.log(arg.toString());\n    }\n  },\n  test: new class extends Function {\n    apply(arg, scope, visitors) {\n      return arg;\n    }\n  },\n  _methods: new Map([\n    [Number, {\n      toString: new class extends Function {\n        apply() { return this.toString(); }\n      },\n      mapTo: new class extends Function {\n        *apply([to, step, mapper], scope, visitors) {\n          const lastIndex = (to - this) / step;\n\n          for (let index = 0; index <= lastIndex; ++index) {\n            yield mapper.apply(index * step + this, scope, visitors);\n          }\n        }\n      },\n    }],\n    [String, {\n      toString: new class extends Function {\n        apply() { return this.toString(); }\n      },\n      mapTo: new class extends Function {\n        *apply([to, step, mapper], scope, visitors) {\n          const last = String.fromCharCode(to.codePointAt(0));\n\n          for (let index = 0; String.fromCharCode(this.codePointAt(0) + index) <= last; index += step) {\n            yield mapper.apply(String.fromCharCode(this.codePointAt(0) + index), scope, visitors);\n          }\n        }\n      },\n    }],\n    [Range, {\n      map: new class extends Function {\n        apply(mapper, scope, visitors) {\n          return [...scope._methods.get(this.from.constructor)['mapTo'].apply.call(\n            this.from, [this.to, this.step, mapper], scope, visitors\n          )];\n        }\n      }\n    }],\n  ]),\n};\n\nmodule.exports = {\n  default: scope\n};\n\n\n//# sourceURL=webpack://kopi2/./bin/scope.js?");

/***/ }),

/***/ "./lib/parser.js":
/*!***********************!*\
  !*** ./lib/parser.js ***!
  \***********************/
/***/ ((module) => {

"use strict";
eval("/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { Statement: peg$parseStatement },\n      peg$startRuleFunction  = peg$parseStatement,\n\n      peg$c0 = \"=\",\n      peg$c1 = peg$literalExpectation(\"=\", false),\n      peg$c2 = function(pattern, expr) {\n            return new Assignment({\n              _pattern: pattern,\n              _expr: expr\n            })\n          },\n      peg$c3 = \"|\",\n      peg$c4 = peg$literalExpectation(\"|\", false),\n      peg$c5 = function(head, tail) {\n            return tail.reduce((result, [, operator,, value]) => (\n              new PipeExpression({\n                _op: operator,\n                _left: result,\n                _right: value\n              })\n            ), head);\n          },\n      peg$c6 = function(expr, args) {\n            return args.reduce((result, [, arg]) => (\n              new ApplyExpression({\n                _expr: result,\n                _args: arg\n              })\n            ), expr);\n          },\n      peg$c7 = \"=>\",\n      peg$c8 = peg$literalExpectation(\"=>\", false),\n      peg$c9 = function(pattern, expr) {\n            return new FunctionExpression({\n              _params: pattern,\n              _body: expr\n            })\n          },\n      peg$c10 = \":\",\n      peg$c11 = peg$literalExpectation(\":\", false),\n      peg$c12 = \",\",\n      peg$c13 = peg$literalExpectation(\",\", false),\n      peg$c14 = function(headNames, tailNames) {\n            return tailNames.length === 0 ? headNames[3] : new TupleExpression({\n              _elements: buildList(headNames[3], tailNames, 6),\n              _fields: buildList(headNames[0], tailNames, 3)\n            });\n          },\n      peg$c15 = function(head, tail, tailNames) {\n            return [...tail, ...tailNames].length === 0 ? head : new TupleExpression({\n              _elements: [...buildList(head, tail, 4), ...buildList(undefined, tailNames, 6)],\n              _fields: [...buildList(null, tail, undefined), ...buildList(undefined, tailNames, 3)],\n            });\n          },\n      peg$c16 = \"..\",\n      peg$c17 = peg$literalExpectation(\"..\", false),\n      peg$c18 = function(from, to) {\n          return new RangeExpression({ from: from, to: to });\n        },\n      peg$c19 = \"+\",\n      peg$c20 = peg$literalExpectation(\"+\", false),\n      peg$c21 = \"-\",\n      peg$c22 = peg$literalExpectation(\"-\", false),\n      peg$c23 = function(head, tail) {\n            return tail.reduce((result, [, operator,, value]) => (\n              new OperatorExpression({\n                op: operator,\n                left: result,\n                right: value\n              })\n            ), head);\n          },\n      peg$c24 = \"*\",\n      peg$c25 = peg$literalExpectation(\"*\", false),\n      peg$c26 = \"/\",\n      peg$c27 = peg$literalExpectation(\"/\", false),\n      peg$c28 = \".\",\n      peg$c29 = peg$literalExpectation(\".\", false),\n      peg$c30 = function(head, tail) {\n            return tail.reduce((result, [, field]) => (\n              new FieldExpression({\n                expr: result,\n                field: field\n              })\n            ), head);\n          },\n      peg$c31 = \"'\",\n      peg$c32 = peg$literalExpectation(\"'\", false),\n      peg$c33 = function(expr) {\n            return new AstNode({\n              _expr: expr\n            });\n          },\n      peg$c34 = \"(\",\n      peg$c35 = peg$literalExpectation(\"(\", false),\n      peg$c36 = \")\",\n      peg$c37 = peg$literalExpectation(\")\", false),\n      peg$c38 = function(head) {\n            return head ? head : new TupleExpression({\n              _elements: [],\n              _fields: []\n            })\n          },\n      peg$c39 = function(head, tail) {\n            return tail.length === 0 ? head : new TuplePattern({\n              elements: tail.reduce((r, e) => [...r, e[3]], [head])\n            })\n          },\n      peg$c40 = function(expr) {\n            return new AstNodeIdentifierPattern({\n              _expr: expr\n            });\n          },\n      peg$c41 = function(name) {\n            return new IdentifierPattern({\n              _name: name,\n            })\n          },\n      peg$c42 = peg$otherExpectation(\"number\"),\n      peg$c43 = /^[0-9]/,\n      peg$c44 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c45 = function(literal) {\n            return new NumericLiteral({\n              value: Number(text()),\n            })\n          },\n      peg$c46 = peg$otherExpectation(\"string\"),\n      peg$c47 = \"\\\"\",\n      peg$c48 = peg$literalExpectation(\"\\\"\", false),\n      peg$c49 = peg$anyExpectation(),\n      peg$c50 = function(chars) {\n            return new StringLiteral({\n              value: chars.map(([, c]) => c).join(\"\"),\n            });\n          },\n      peg$c51 = \"[\",\n      peg$c52 = peg$literalExpectation(\"[\", false),\n      peg$c53 = \"]\",\n      peg$c54 = peg$literalExpectation(\"]\", false),\n      peg$c55 = function(head, tail) {\n            return new ArrayLiteral({\n              elements: tail.reduce((result, [,,, expr]) => [...result, expr], [head])\n            })\n          },\n      peg$c56 = \"[]\",\n      peg$c57 = peg$literalExpectation(\"[]\", false),\n      peg$c58 = function() {\n          return new ArrayLiteral({\n            elements: []\n          })\n        },\n      peg$c59 = peg$otherExpectation(\"identifier\"),\n      peg$c60 = function(name) {\n            return new Identifier({\n              name: name,\n            })\n          },\n      peg$c61 = /^[a-z]/,\n      peg$c62 = peg$classExpectation([[\"a\", \"z\"]], false, false),\n      peg$c63 = /^[a-zA-Z0-9]/,\n      peg$c64 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n      peg$c65 = function() {\n            return text();\n          },\n      peg$c66 = peg$otherExpectation(\"whitespace\"),\n      peg$c67 = \" \",\n      peg$c68 = peg$literalExpectation(\" \", false),\n      peg$c69 = peg$otherExpectation(\"newline\"),\n      peg$c70 = /^[\\n\\r]/,\n      peg$c71 = peg$classExpectation([\"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseStatement() {\n    var s0;\n\n    s0 = peg$parseAssignment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsePipeExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parseAssignment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseTuplePattern();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 61) {\n          s3 = peg$c0;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c1); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsePipeExpression();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c2(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePipeExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseApplyExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s5 = peg$c3;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c4); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsePipeApplyExpression();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 124) {\n            s5 = peg$c3;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c4); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsePipeApplyExpression();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c5(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePipeApplyExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseFunctionExpression();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseFunctionExpression();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseApplyExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseFunctionExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseFunctionExpression();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseFunctionExpression();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFunctionExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseTuplePattern();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c7) {\n          s3 = peg$c7;\n          peg$currPos += 2;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseApplyExpression();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c9(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseTupleExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parseTupleExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseIdentifier();\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s3 = peg$c10;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c11); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseRangeExpression();\n          if (s5 !== peg$FAILED) {\n            s2 = [s2, s3, s4, s5];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c12;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c13); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseIdentifier();\n            if (s7 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s8 = peg$c10;\n                peg$currPos++;\n              } else {\n                s8 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c11); }\n              }\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parse_();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parseRangeExpression();\n                  if (s10 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7, s8, s9, s10];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c12;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseIdentifier();\n              if (s7 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 58) {\n                  s8 = peg$c10;\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c11); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s9 = peg$parse_();\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parseRangeExpression();\n                    if (s10 !== peg$FAILED) {\n                      s4 = [s4, s5, s6, s7, s8, s9, s10];\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c14(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseRangeExpression();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c12;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$currPos;\n              peg$silentFails++;\n              s8 = peg$currPos;\n              s9 = peg$parseIdentifier();\n              if (s9 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 58) {\n                  s10 = peg$c10;\n                  peg$currPos++;\n                } else {\n                  s10 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c11); }\n                }\n                if (s10 !== peg$FAILED) {\n                  s9 = [s9, s10];\n                  s8 = s9;\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              peg$silentFails--;\n              if (s8 === peg$FAILED) {\n                s7 = void 0;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parseRangeExpression();\n                if (s8 !== peg$FAILED) {\n                  s4 = [s4, s5, s6, s7, s8];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c12;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c13); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$currPos;\n                peg$silentFails++;\n                s8 = peg$currPos;\n                s9 = peg$parseIdentifier();\n                if (s9 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 58) {\n                    s10 = peg$c10;\n                    peg$currPos++;\n                  } else {\n                    s10 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c11); }\n                  }\n                  if (s10 !== peg$FAILED) {\n                    s9 = [s9, s10];\n                    s8 = s9;\n                  } else {\n                    peg$currPos = s8;\n                    s8 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s8;\n                  s8 = peg$FAILED;\n                }\n                peg$silentFails--;\n                if (s8 === peg$FAILED) {\n                  s7 = void 0;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseRangeExpression();\n                  if (s8 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7, s8];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$currPos;\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s6 = peg$c12;\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c13); }\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parse_();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parseIdentifier();\n                if (s8 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 58) {\n                    s9 = peg$c10;\n                    peg$currPos++;\n                  } else {\n                    s9 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c11); }\n                  }\n                  if (s9 !== peg$FAILED) {\n                    s10 = peg$parse_();\n                    if (s10 !== peg$FAILED) {\n                      s11 = peg$parseRangeExpression();\n                      if (s11 !== peg$FAILED) {\n                        s5 = [s5, s6, s7, s8, s9, s10, s11];\n                        s4 = s5;\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$parse_();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s6 = peg$c12;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c13); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parseIdentifier();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 58) {\n                      s9 = peg$c10;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c11); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parse_();\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parseRangeExpression();\n                        if (s11 !== peg$FAILED) {\n                          s5 = [s5, s6, s7, s8, s9, s10, s11];\n                          s4 = s5;\n                        } else {\n                          peg$currPos = s4;\n                          s4 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s4;\n                        s4 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s4;\n                      s4 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c15(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseRangeExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseAddExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c16) {\n          s3 = peg$c16;\n          peg$currPos += 2;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c17); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseAddExpression();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c18(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseAddExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parseAddExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseMultiplyExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s5 = peg$c19;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c20); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s5 = peg$c21;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c22); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseMultiplyExpression();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 43) {\n            s5 = peg$c19;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c20); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 45) {\n              s5 = peg$c21;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c22); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseMultiplyExpression();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c23(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiplyExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseFieldExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s5 = peg$c24;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c25); }\n        }\n        if (s5 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s5 = peg$c26;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c27); }\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseFieldExpression();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s5 = peg$c24;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c25); }\n          }\n          if (s5 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 47) {\n              s5 = peg$c26;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c27); }\n            }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseFieldExpression();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c23(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFieldExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrimaryExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s4 = peg$c28;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseIdentifier();\n        if (s5 === peg$FAILED) {\n          s5 = peg$parseNumericLiteral();\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s4 = peg$c28;\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c29); }\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseIdentifier();\n          if (s5 === peg$FAILED) {\n            s5 = peg$parseNumericLiteral();\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c30(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrimaryExpression() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$parseLiteral();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseIdentifier();\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s1 = peg$c31;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseIdentifier();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseLiteral();\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c33(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 39) {\n            s1 = peg$c31;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s2 = peg$c34;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c35); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseStatement();\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parse_();\n                  if (s5 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 41) {\n                      s6 = peg$c36;\n                      peg$currPos++;\n                    } else {\n                      s6 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c37); }\n                    }\n                    if (s6 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c33(s4);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s1 = peg$c34;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c35); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsePipeExpression();\n              if (s2 === peg$FAILED) {\n                s2 = null;\n              }\n              if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s3 = peg$c36;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c37); }\n                }\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c38(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseApplyExpressionInArrayExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseFunctionExpressionInArrayExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseFunctionExpressionInArrayExpression();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseFunctionExpressionInArrayExpression();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c6(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFunctionExpressionInArrayExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseTuplePattern();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c7) {\n          s3 = peg$c7;\n          peg$currPos += 2;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseApplyExpressionInArrayExpression();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c9(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseRangeExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parseTuplePattern() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrimaryPattern();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c12;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c13); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsePrimaryPattern();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c12;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse_();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsePrimaryPattern();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c39(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrimaryPattern() {\n    var s0, s1, s2;\n\n    s0 = peg$parseIdentifierPattern();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c31;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseIdentifierPattern();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c40(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierPattern() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c41(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLiteral() {\n    var s0;\n\n    s0 = peg$parseNumericLiteral();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseStringLiteral();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseArrayLiteral();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumericLiteral() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c43.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c44); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c28;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c29); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s5 = peg$c28;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c29); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = [];\n          if (peg$c43.test(input.charAt(peg$currPos))) {\n            s6 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c44); }\n          }\n          if (s6 !== peg$FAILED) {\n            while (s6 !== peg$FAILED) {\n              s5.push(s6);\n              if (peg$c43.test(input.charAt(peg$currPos))) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n            }\n          } else {\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c45(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c42); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringLiteral() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c47;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s5 = peg$c47;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c49); }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s5 = peg$c47;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c49); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s3 = peg$c47;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c50(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseArrayLiteral() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c51;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c52); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseApplyExpressionInArrayExpression();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parse_();\n        if (s5 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s6 = peg$c12;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c13); }\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parse_();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parseApplyExpressionInArrayExpression();\n              if (s8 !== peg$FAILED) {\n                s5 = [s5, s6, s7, s8];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          s5 = peg$parse_();\n          if (s5 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s6 = peg$c12;\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c13); }\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parse_();\n              if (s7 !== peg$FAILED) {\n                s8 = peg$parseApplyExpressionInArrayExpression();\n                if (s8 !== peg$FAILED) {\n                  s5 = [s5, s6, s7, s8];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s4 = peg$c53;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c54); }\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c55(s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c56) {\n        s1 = peg$c56;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c57); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c58();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifier() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c60(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c59); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierName() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c61.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c62); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      if (peg$c63.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$c63.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c64); }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c65();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n    }\n\n    return s0;\n  }\n\n  function peg$parseWhiteSpace() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s0 = peg$c67;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c68); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c66); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminator() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c70.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c71); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c69); }\n    }\n\n    return s0;\n  }\n\n\n    function extractList(list, index) {\n      return list.map(function(element) { return index !== undefined ? element[index] : null; });\n    }\n\n    function buildList(head, tail, index) {\n      return [...(head !== undefined ? [head] : []) ].concat(extractList(tail, index));\n    }\n\n    class Node {\n      constructor(properties) {\n        Object.assign(this, properties);\n      }\n    }\n\n    class AstNode extends Node { }\n    class AstIdentifierNode extends Node { }\n    class Assignment extends Node { }\n\n    class PipeExpression extends Node { }\n    class ApplyExpression extends Node { }\n    class TupleExpression extends Node { }\n    class FunctionExpression extends Node { }\n    class RangeExpression extends Node { }\n    class OperatorExpression extends Node { }\n    class FieldExpression extends Node { }\n\n    class AstNodeIdentifierPattern extends Node { }\n    class TuplePattern extends Node { }\n    class IdentifierPattern extends Node { }\n\n    class NumericLiteral extends Node { }\n    class StringLiteral extends Node { }\n    class ArrayLiteral extends Node { }\n\n    class Identifier extends Node { }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n//# sourceURL=webpack://kopi2/./lib/parser.js?");

/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/***/ ((module) => {

eval("class BaseError extends Error {\n  constructor(message) {\n    super(message);\n\n    this.name = this.constructor.name;\n  }\n}\n\nclass InterpreterError extends BaseError { }\nclass RuntimeError extends BaseError { }\n\nmodule.exports = {\n  InterpreterError,\n  RuntimeError\n};\n\n\n//# sourceURL=webpack://kopi2/./src/errors.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/parser */ \"./lib/parser.js\");\n/* harmony import */ var _lib_parser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_parser__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _visitors_TypecheckVisitors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./visitors/TypecheckVisitors */ \"./src/visitors/TypecheckVisitors.js\");\n/* harmony import */ var _visitors_TypecheckVisitors__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_visitors_TypecheckVisitors__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _visitors_InterpreterVisitors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./visitors/InterpreterVisitors */ \"./src/visitors/InterpreterVisitors.js\");\n/* harmony import */ var _visitors_InterpreterVisitors__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_visitors_InterpreterVisitors__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _bin_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bin/context */ \"./bin/context.js\");\n/* harmony import */ var _bin_context__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_bin_context__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _bin_scope__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../bin/scope */ \"./bin/scope.js\");\n/* harmony import */ var _bin_scope__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_bin_scope__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\n\n\nconst history = document.querySelector('.history');\nconst line = document.querySelector('.line');\n\nconst exampleClick = (event) => {\n  if (event.target.innerText) {\n    line.value = event.target.innerText;\n    line.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }));\n  }\n};\n\nconst examples = document.querySelectorAll('.examples div');\nexamples.forEach(example => {\n  example.addEventListener('click', exampleClick);\n});\n\nline.focus();\n\nconst typecheckVisitors = new (_visitors_TypecheckVisitors__WEBPACK_IMPORTED_MODULE_1___default().default)();\n\nconst visitors = new (_visitors_InterpreterVisitors__WEBPACK_IMPORTED_MODULE_2___default().default)();\n\nconst inspect = value => {\n  if (typeof value === 'object') {\n    const props = Object.entries(value).map(([name, value]) => `${name}: ${inspect(value)}`);\n\n    return `${value.constructor.name} { ${props.join(', ')} }`;\n  } else if (typeof value === 'string') {\n    return `\"${value}\"`;\n  } else if (typeof value === 'number') {\n    return `${value}`;\n  }\n};\n\n//\n\nlet context = (_bin_context__WEBPACK_IMPORTED_MODULE_3___default().default);\nlet scope = (_bin_scope__WEBPACK_IMPORTED_MODULE_4___default().default);\n\nObject.entries(scope).forEach(([name, value]) => {\n  if (context[name]?.params) {\n    value.params = context[name].params;\n    value.rettype = context[name].rettype;\n    value.type = context[name];\n  }\n});\n\nconst bindTypes = types => context = { ...context, ...types };\nconst bind = variables => scope = { ...scope, ...variables };\n\nline.addEventListener('keydown', event => {\n  if (event.key === 'Enter') {\n    if (event.target.value === '') {\n      return;\n    }\n\n    const ast = (0,_lib_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(event.target.value);\n\n    console.log(ast);\n\n    const div1 = document.createElement('div');\n    div1.textContent = `> ${event.target.value}`;\n\n    history.appendChild(div1);\n\n    try {\n      const type = typecheckVisitors.visitNode(ast, context, bindTypes);\n      const value = visitors.visitNode(ast, scope, bind);\n\n      if (value !== undefined) {\n        const div = document.createElement('div');\n\n        if (value.toElement) {\n          div.appendChild(value.toElement());\n        } else {\n          div.textContent = `${value.escape()} :: ${type?.escape()}`;\n        }\n\n        history.appendChild(div);\n      }\n    } catch (error) {\n      console.error(error);\n\n      const div = document.createElement('div');\n      div.textContent = error;\n\n      history.appendChild(div);\n    }\n\n    line.value = '';\n  }\n});\n\n\n//# sourceURL=webpack://kopi2/./src/index.js?");

/***/ }),

/***/ "./src/visitors/BaseVisitor.js":
/*!*************************************!*\
  !*** ./src/visitors/BaseVisitor.js ***!
  \*************************************/
/***/ ((module) => {

eval("class BaseVisitors {\n  constructor(error) {\n    this.error = error;\n  }\n\n  visitNode(node, scope, bind) {\n    if (node === null) {\n      return undefined;\n    }\n\n    if (this[node.constructor.name]) {\n      return this[node.constructor.name](node, scope, bind);\n    } else {\n      throw new Error(`No AST node visitor for ${this.constructor.name} '${node.constructor.name}'`);\n    }\n  }\n}\n\nmodule.exports = {\n  default: BaseVisitors\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/BaseVisitor.js?");

/***/ }),

/***/ "./src/visitors/InterpreterVisitors.js":
/*!*********************************************!*\
  !*** ./src/visitors/InterpreterVisitors.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { default: BaseVisitors } = __webpack_require__(/*! ./BaseVisitor */ \"./src/visitors/BaseVisitor.js\");\nconst { RuntimeError } = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\nconst { AstNode, IdentifierPattern, TuplePattern, AstIdentifierNode, AstNodeIdentifierPattern, Tuple, Range, Function } = __webpack_require__(/*! ./classes */ \"./src/visitors/classes/index.js\");\nconst { default: TypecheckVisitors } = __webpack_require__(/*! ./TypecheckVisitors */ \"./src/visitors/TypecheckVisitors.js\");\n\nclass InterpreterVisitors extends BaseVisitors {\n  AstNode({ _expr }) {\n    return new AstNode(_expr);\n  }\n\n  Assignment({ _pattern, _expr }, scope, bind) {\n    const evaluatedPattern = this.visitNode(_pattern, scope);\n    const value = this.visitNode(_expr, scope);\n\n    // TODO: Pass _expr to matchValue so FunctionPattern can bind\n    const matches = evaluatedPattern.matchValue(value, scope);\n\n    bind(matches);\n  }\n\n  PipeExpression({ _left, _right }, scope) {\n    const left = this.visitNode(_left, scope);\n\n    if (_right._args) {\n      const args = this.visitNode(_right._args, scope);\n\n      return scope._methods.get(left.constructor)[_right._expr.name].apply.apply(left, [args, scope, this]);\n    }\n\n    return scope._methods.get(left.constructor)[_right.name].apply.apply(left);\n  }\n\n  ApplyExpression({ _expr, _args }, scope) {\n    const value = this.visitNode(_expr, scope);\n    const args = this.visitNode(_args, scope);\n\n    return value.apply(args, scope, this);\n  }\n\n  TupleExpression({ _elements, _fields, type }, scope) {\n    const tuple = new Tuple(\n      _elements.map(element => this.visitNode(element, scope)),\n      _fields.map(field => field?.name)\n    );\n    tuple.type = type;\n\n    return tuple;\n  }\n\n  FunctionExpression({ _params, _body, type }, scope) {\n    const evaluatedParams = this.visitNode(_params, scope);\n\n    const func = new Function(evaluatedParams, type?.rettype, _body, scope);\n    func.type = type;\n\n    return func;\n  }\n\n  RangeExpression({ from, to, type }, scope) {\n    const range = new Range(this.visitNode(from, scope), this.visitNode(to, scope));\n    range.type = type;\n\n    return range;\n  }\n\n  OperatorExpression({ left, op, right }, scope) {\n    const evaluatedLeft = this.visitNode(left, scope);\n    const evaluatedRight = this.visitNode(right, scope);\n\n    if (typeof evaluatedLeft === 'number' && typeof evaluatedRight === 'number') {\n      switch (op) {\n        case '+': return evaluatedLeft + evaluatedRight;\n        case '-': return evaluatedLeft - evaluatedRight;\n        case '*': return evaluatedLeft * evaluatedRight;\n        case '/': return evaluatedLeft / evaluatedRight;\n      }\n    }\n  }\n\n  // TODO: Add ArrayFieldExpression and return Union type | ()\n  FieldExpression({ expr, field }, scope) {\n    return this.visitNode(expr, scope).valueForField(field.name || field.value);\n  }\n\n  TuplePattern({ elements, type }, scope) {\n    const tuple = new TuplePattern(elements.map(element => this.visitNode(element, scope)));\n    tuple.type = type;\n\n    return tuple;\n  }\n\n  IdentifierPattern({ _name }) {\n    return new IdentifierPattern(_name);\n  }\n\n  AstNodeIdentifierPattern({ _expr }) {\n    return new AstNodeIdentifierPattern(_expr);\n  }\n\n  NumericLiteral({ value }) {\n    return value;\n  }\n\n  StringLiteral({ value }) {\n    return value;\n  }\n\n  ArrayLiteral({ elements, type }, scope) {\n    const array = elements.map(element => this.visitNode(element, scope));\n    array.type = type;\n\n    return array;\n  }\n\n  Identifier({ name }, scope) {\n    return scope[name];\n  }\n}\n\nmodule.exports = {\n  default: InterpreterVisitors\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/InterpreterVisitors.js?");

/***/ }),

/***/ "./src/visitors/PrintCodeVisitors.js":
/*!*******************************************!*\
  !*** ./src/visitors/PrintCodeVisitors.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { default: BaseVisitors } = __webpack_require__(/*! ./BaseVisitor */ \"./src/visitors/BaseVisitor.js\");\n\nclass PrintCodeVisitors extends BaseVisitors {\n  AstNode({ _expr }) {\n    return `('${this.visitNode(_expr)})`;\n  }\n\n  // AstIdentifierNode({ _expr }) {\n  //   return new AstIdentifierNode(_expr);\n  // }\n\n  Assignment({ _pattern, _expr }, scope, bind) {\n    return `${this.visitNode(_pattern)} = ${this.visitNode(_expr)}`;\n  }\n\n  ApplyExpression({ _expr, _args }, scope) {\n    return `(${this.visitNode(_expr)} ${this.visitNode(_args)})`;\n  }\n\n  TupleExpression({ _elements }, scope) {\n    return `(${_elements.map(element => this.visitNode(element, scope)).join(', ')})`;\n  }\n\n  FunctionExpression({ _params, _body }, scope) {\n    return `${this.visitNode(_params)} => ${this.visitNode(_body)}`;\n  }\n\n  Function({ params, body }) {\n    return `${this.visitNode(params)} => ${this.visitNode(body)}`;\n  }\n\n  IdentifierPattern({ _name, name }) {\n    return `${_name || name}`;\n  }\n\n  // AstNodeIdentifierPattern({ _expr }) {\n  //   return new AstNodeIdentifierPattern(_expr);\n  // }\n\n  NumericLiteral({ value }) {\n    return `${value}`;\n  }\n\n  StringLiteral({ value }) {\n    return `\"${value}\"`;\n  }\n\n  Identifier({ name }, scope) {\n    return `${name}`;\n  }\n}\n\nmodule.exports = {\n  default: PrintCodeVisitors\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/PrintCodeVisitors.js?");

/***/ }),

/***/ "./src/visitors/TypecheckVisitors.js":
/*!*******************************************!*\
  !*** ./src/visitors/TypecheckVisitors.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { default: BaseVisitors } = __webpack_require__(/*! ./BaseVisitor */ \"./src/visitors/BaseVisitor.js\");\nconst { InterpreterError } = __webpack_require__(/*! ../errors */ \"./src/errors.js\");\nconst { AnyType, NoneType, AstNodeType, BooleanType, NumberType, StringType, TupleType, FunctionType, RangeType, UnionType, ArrayType } = __webpack_require__(/*! ./types */ \"./src/visitors/types/index.js\");\nconst { IdentifierPattern, TuplePattern, AstNodeIdentifierPattern, Tuple, Function } = __webpack_require__(/*! ./classes */ \"./src/visitors/classes/index.js\");\n\nclass TypecheckVisitors extends BaseVisitors {\n  AstNode({ _expr }) {\n    return AstNodeType();\n  }\n\n  // AstIdentifierNode({ _expr }) {\n\n  // }\n\n  Assignment({ _pattern, _expr }, context, bind) {\n    const pattern = this.visitNode(_pattern, context);\n    const type = this.visitNode(_expr, context);\n\n    if (!pattern.matchValue) {\n      throw new InterpreterError(`No matchValue method defined for pattern '${_pattern.constructor.name}'`);\n    }\n\n    const matches = pattern.matchType(type, context);\n\n    bind(matches);\n  }\n\n  PipeExpression(astNode, context) {\n    const { _left, _right } = astNode;\n\n    const type = this.visitNode(_left, context);\n    // const args = this.visitNode(_right, context);\n  }\n\n  FunctionExpression(astNode, context) {\n    const { _params, _body } = astNode;\n\n    const params = this.visitNode(_params, context);\n    // TODO: Find rettype of body\n    // const body = this.visitNode(_body, { x: params.type, ...context });\n\n    return astNode.type = FunctionType(params, undefined, _body, context);\n  }\n\n  ApplyExpression(astNode, context) {\n    const { _expr, _args } = astNode;\n\n    const type = this.visitNode(_expr, context);\n    const args = this.visitNode(_args, context);\n\n    if (!type.params) {\n      throw new TypeError(`Function application not defined for type '${type.name}.'`);\n    }\n\n    const matches = type.params.matchType(args);\n\n    if (!matches) {\n      throw new TypeError(`Argument to function '${_expr?.name}' should be type '${type.params.type?.name}', but found '${args.name}'.`);\n    }\n\n    if (type.body) {\n      return this.visitNode(type.body, { ...type.context, ...matches });\n    }\n\n    return astNode.type = type.rettype;\n  }\n\n  TupleExpression(astNode, context) {\n    const { _elements, _fields } = astNode;\n\n    return astNode.type = TupleType(\n      _elements.map(element => this.visitNode(element, context)),\n      _fields.map(field => field?.name)\n    );\n  }\n\n  RangeExpression(astNode, context) {\n    const { from, to } = astNode;\n\n    if (!this.visitNode(from, context).includesType(this.visitNode(to, context))) {\n      throw new TypeError(`Range types must be equal`);\n    }\n\n    return astNode.type = RangeType(this.visitNode(from, context), this.visitNode(to, context));\n  }\n\n  OperatorExpression(astNode, context) {\n    const { left, op, right } = astNode;\n\n    const evaluatedLeft = this.visitNode(left, context);\n    const evaluatedRight = this.visitNode(right, context);\n\n    if (evaluatedLeft.includesType(NumberType())) {\n      if (!evaluatedRight.includesType(NumberType())) {\n        throw new TypeError(`Argument to operator 'Number.${op}' should be type 'Number', but found '${evaluatedRight.name}'`);\n      }\n    }\n\n    return evaluatedRight;\n  }\n\n  FieldExpression(astNode, context) {\n    const { expr, field } = astNode;\n\n    const evaluatedExpr = this.visitNode(expr, context);\n\n    const type = evaluatedExpr.typeForField(field);\n\n    if (!type) {\n      throw new TypeError(`Tuple index ${field.name || field.value} is out of bounds`);\n    }\n\n    return astNode.type = type;\n  }\n\n  //\n\n  TuplePattern(astNode, context) {\n    const { elements } = astNode;\n\n    return astNode.type = new TuplePattern(elements.map(element => this.visitNode(element, context)));\n  }\n\n  IdentifierPattern({ _name }, context) {\n    // TODO: Add generic type variable\n    return new IdentifierPattern(_name, undefined);\n  }\n\n  AstNodeIdentifierPattern({ _expr }) {\n    return new AstNodeIdentifierPattern(_expr);\n  }\n\n  //\n\n  NumericLiteral(astNode) {\n    const { value } = astNode;\n\n    if (typeof value !== 'number') {\n      throw TypeError(`Value is not a number.`);\n    }\n\n    return astNode.type = NumberType();\n  }\n\n  StringLiteral(astNode) {\n    const { value } = astNode;\n\n    if (typeof value !== 'string') {\n      throw TypeError(`Value is not a string.`);\n    }\n\n    return astNode.type = StringType();\n  }\n\n  ArrayLiteral(astNode, context) {\n    const { elements } = astNode;\n\n    // console.error('> ArrayLiteral', { elements });\n\n    if (elements.length === 0) {\n      return astNode.type = ArrayType(NoneType());\n    }\n\n    const valueTypes = elements.map(element => this.visitNode(element, context));\n\n    const valueTypesSet = valueTypes.filter(\n      (valueType, index) => index === valueTypes.findIndex((t) => t.includesType(valueType))\n    );\n\n    if (valueTypesSet.every(valueType => valueType.elementType?.includesType(NoneType()))) {\n      return astNode.type = ArrayType(valueTypesSet[0]);\n    }\n\n    const filteredValueTypesSet = valueTypesSet.filter(valueType => !(valueType.elementType?.includesType(NoneType())));\n\n    if (filteredValueTypesSet.length === 1) {\n      return astNode.type = ArrayType(filteredValueTypesSet[0]);\n    }\n\n    return astNode.type = ArrayType(UnionType(...filteredValueTypesSet));\n  }\n\n  Identifier(astNode, context) {\n    // console.error('Identifier', name, context);\n\n    const { name } = astNode;\n\n    if (!context[name]) {\n      throw new Error(`Variable '${name}' is not defined in the current scope.`);\n    }\n\n    return astNode.type = context[name];\n  }\n}\n\nmodule.exports = {\n  default: TypecheckVisitors\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/TypecheckVisitors.js?");

/***/ }),

/***/ "./src/visitors/classes/AstNode.js":
/*!*****************************************!*\
  !*** ./src/visitors/classes/AstNode.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { default: PrintCodeVisitors } = __webpack_require__(/*! ../PrintCodeVisitors */ \"./src/visitors/PrintCodeVisitors.js\");\n\nconst visitors = new PrintCodeVisitors();\n\nclass AstNode {\n  constructor(expr) {\n    this.expr = expr;\n  }\n\n  escape() {\n    return `'${visitors.visitNode(this.expr)}`;\n  }\n\n  toString() {\n    return `'${visitors.visitNode(this.expr)}`;\n  }\n}\n\nmodule.exports = {\n  default: AstNode,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/AstNode.js?");

/***/ }),

/***/ "./src/visitors/classes/AstNodeIdentifierPattern.js":
/*!**********************************************************!*\
  !*** ./src/visitors/classes/AstNodeIdentifierPattern.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("class AstNodeIdentifierPattern {\n  constructor(expr) {\n    this.expr = expr;\n  }\n\n  escape() {\n    return this.expr;\n  }\n\n  matchValue(value) {\n    return null;\n  }\n\n  matchType(type) {\n    if (type.name !== this.expr._name) {\n      throw Error(`Match expects identifier pattern '${this.expr._name}', but got '${type.name}'`);\n    }\n  }\n}\n\nmodule.exports = {\n  default: AstNodeIdentifierPattern,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/AstNodeIdentifierPattern.js?");

/***/ }),

/***/ "./src/visitors/classes/Function.js":
/*!******************************************!*\
  !*** ./src/visitors/classes/Function.js ***!
  \******************************************/
/***/ ((module) => {

eval("// const util = require(\"util\");\n\nclass Function {\n  constructor(params, rettype, body, scope) {\n    this.params = params;\n    this.rettype = rettype;\n    this.body = body;\n    this.closure = scope;\n\n    // if (this.closure) this.closure[util.inspect.custom] = () => {\n    //   return '{ ... }';\n    // };\n\n    Object.defineProperty(this, 'toString', {\n      value: undefined,\n    });\n  }\n\n  escape() {\n    return `<function>`;\n  }\n\n  // get type() {\n  //   return FunctionType(this.params, this.rettype);\n  // }\n\n  apply(args, scope, visitors) {\n    const matches = this.params.matchValue(args);\n\n    return visitors.visitNode(this.body, { ...this.closure, ...matches });\n  }\n}\n\nmodule.exports = {\n  default: Function,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/Function.js?");

/***/ }),

/***/ "./src/visitors/classes/IdentifierPattern.js":
/*!***************************************************!*\
  !*** ./src/visitors/classes/IdentifierPattern.js ***!
  \***************************************************/
/***/ ((module) => {

eval("class IdentifierPattern {\n  constructor(name, type) {\n    this.name = name;\n    this.type = type;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  matchValue(value) {\n    return {\n      [this.name]: value\n    };\n  }\n\n  matchType(type) {\n    // console.log('IdentifierPattern.matchType()', this.type, type);\n\n    if (this.type && !this.type.includesType(type)) {\n      return null;\n    }\n\n    return {\n      [this.name]: type\n    };\n  }\n}\n\nmodule.exports = {\n  default: IdentifierPattern,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/IdentifierPattern.js?");

/***/ }),

/***/ "./src/visitors/classes/Range.js":
/*!***************************************!*\
  !*** ./src/visitors/classes/Range.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { TupleType } = __webpack_require__(/*! ../types */ \"./src/visitors/types/index.js\");\n\nclass Range {\n  constructor(from, to, step = 1) {\n    this.from = from;\n    this.to = to;\n    this.step = step;\n  }\n\n  escape() {\n    return `${this.from.escape()}..${this.to.escape()}`;\n  }\n\n  //\n\n  valueForField(field) {\n    if (typeof field === 'number') {\n      return field + this.from <= this.to ? this.from + field : TupleType();\n    }\n  }\n\n  apply(args) {\n    return new Range(this.from, this.to, args);\n  }\n}\n\nmodule.exports = {\n  default: Range,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/Range.js?");

/***/ }),

/***/ "./src/visitors/classes/Tuple.js":
/*!***************************************!*\
  !*** ./src/visitors/classes/Tuple.js ***!
  \***************************************/
/***/ ((module) => {

eval("class Tuple {\n  constructor(elements = [], fields = []) {\n    this.elements = elements;\n    this.fields = fields;\n  }\n\n  escape() {\n    return `(${this.elements.map((element, index) => (\n      `${this.fields[index] ? `${this.fields[index]}: ` : ''}${element.escape()}`)\n    ).join(', ')})`;\n  }\n\n  toString() {\n    return `${this.elements.join(', ')}`;\n  }\n\n  //\n\n  valueForField(field) {\n    if (typeof field === 'number') {\n      return this.elements[field];\n    }\n\n    return this.elements[this.fields.indexOf(field)];\n  }\n}\n\nmodule.exports = {\n  default: Tuple,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/Tuple.js?");

/***/ }),

/***/ "./src/visitors/classes/TuplePattern.js":
/*!**********************************************!*\
  !*** ./src/visitors/classes/TuplePattern.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { NumberType } = __webpack_require__(/*! ../types */ \"./src/visitors/types/index.js\");\n\nclass TuplePattern {\n  constructor(elements) {\n    this.elements = elements;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  matchValue(value) {\n    return this.elements.reduce((scope, element, index) => {\n      const matches = element.matchValue(value.elements[index]);\n\n      return {\n        ...scope,\n        ...matches\n      };\n    }, {});\n  }\n\n  matchType(type) {\n    // console.log('TuplePattern.matchType', type);\n\n    return this.elements.reduce((context, element, index) => {\n      return {\n        ...context,\n        [element.name]: type.types[index]\n      };\n    }, {});\n  }\n}\n\nmodule.exports = {\n  default: TuplePattern,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/TuplePattern.js?");

/***/ }),

/***/ "./src/visitors/classes/index.js":
/*!***************************************!*\
  !*** ./src/visitors/classes/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { default: AstNode } = __webpack_require__(/*! ./AstNode */ \"./src/visitors/classes/AstNode.js\");\nconst { default: AstNodeIdentifierPattern } = __webpack_require__(/*! ./AstNodeIdentifierPattern */ \"./src/visitors/classes/AstNodeIdentifierPattern.js\");\nconst { default: TuplePattern } = __webpack_require__(/*! ./TuplePattern */ \"./src/visitors/classes/TuplePattern.js\");\nconst { default: IdentifierPattern } = __webpack_require__(/*! ./IdentifierPattern */ \"./src/visitors/classes/IdentifierPattern.js\");\nconst { default: Function } = __webpack_require__(/*! ./Function */ \"./src/visitors/classes/Function.js\");\nconst { default: Tuple } = __webpack_require__(/*! ./Tuple */ \"./src/visitors/classes/Tuple.js\");\nconst { default: Range } = __webpack_require__(/*! ./Range */ \"./src/visitors/classes/Range.js\");\n\nmodule.exports = {\n  AstNode,\n  AstNodeIdentifierPattern,\n  TuplePattern,\n  IdentifierPattern,\n  Function,\n  Tuple,\n  Range,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/classes/index.js?");

/***/ }),

/***/ "./src/visitors/types/AnyType.js":
/*!***************************************!*\
  !*** ./src/visitors/types/AnyType.js ***!
  \***************************************/
/***/ ((module) => {

eval("class AnyType {\n  get name() {\n    return `Any`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(type) {\n    return true;\n  }\n\n  isSupertypeOf(valueType) {\n    return true;\n  }\n\n  isSubtypeOf(valueType) {\n    return false;\n  }\n}\n\nmodule.exports = {\n  AnyType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/AnyType.js?");

/***/ }),

/***/ "./src/visitors/types/ArrayType.js":
/*!*****************************************!*\
  !*** ./src/visitors/types/ArrayType.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\nconst { TupleType } = __webpack_require__(/*! ./TupleType */ \"./src/visitors/types/TupleType.js\");\nconst { UnionType } = __webpack_require__(/*! ./UnionType */ \"./src/visitors/types/UnionType.js\");\n\nclass ArrayType extends AnyType {\n  constructor(elementType) {\n    super();\n\n    this.elementType = elementType;\n  }\n\n  get name() {\n    return `Array[${this.elementType?.name ?? ''}]`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(valueType) {\n    // console.log('ArrayType.includesType()', valueType.elementType, this.elementType);\n\n    // return valueType instanceof ArrayType && (valueType.elementType === undefined || valueType.elementType === this.elementType);\n\n    // return valueType instanceof ArrayType\n    //   && (valueType.elementType === undefined || valueType.elementType.includesType(this.elementType));\n\n    return valueType instanceof ArrayType && valueType.elementType.includesType(this.elementType);\n  }\n\n  isSubtypeOf(valueType) {\n    // return valueType instanceof ArrayType && valueType.elementType.includesType(this.elementType);\n  }\n\n  //\n\n  typeForField(field) {\n    if (typeof field.value === 'number') {\n      return new UnionType(this.elementType, new TupleType());\n    }\n\n    if (field.name === 'length') {\n      return NumberType();\n    }\n  }\n}\n\nmodule.exports = {\n  ArrayType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/ArrayType.js?");

/***/ }),

/***/ "./src/visitors/types/AstNodeType.js":
/*!*******************************************!*\
  !*** ./src/visitors/types/AstNodeType.js ***!
  \*******************************************/
/***/ ((module) => {

eval("class AstNodeType {\n  get name() {\n    return `AstNode`;\n  }\n\n  escape() {\n    return this.name;\n  }\n}\n\nmodule.exports = {\n  AstNodeType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/AstNodeType.js?");

/***/ }),

/***/ "./src/visitors/types/BooleanType.js":
/*!*******************************************!*\
  !*** ./src/visitors/types/BooleanType.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\n\nclass BooleanType extends AnyType {\n  get name() {\n    return `Boolean`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(valueType) {\n    return valueType instanceof this.constructor;\n  }\n\n  isSupertypeOf(valueType, visited = new Set(), depth = 0) {\n    if (depth > 2 && visited.has(this)) {\n      return false;\n    }\n\n    return this.isSubtypeOf(valueType, visited.add(this), depth + 1);\n  }\n\n  isSubtypeOf(valueType, visited = new Set(), depth = 0) {\n    if (depth > 2 && visited.has(this)) {\n      return false;\n    }\n\n    return valueType instanceof this.constructor || valueType.isSupertypeOf(this, visited.add(this), depth + 1);\n  }\n}\n\nmodule.exports = {\n  BooleanType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/BooleanType.js?");

/***/ }),

/***/ "./src/visitors/types/FunctionType.js":
/*!********************************************!*\
  !*** ./src/visitors/types/FunctionType.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// const util = require(\"util\");\n\nconst { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\n\nclass FunctionType extends AnyType {\n  constructor(params, rettype, body, context) {\n    super();\n\n    this.params = params;\n    this.rettype = rettype;\n    this.body = body;\n    this.context = context;\n\n    // if (this.context) this.context[util.inspect.custom] = () => {\n    //   return '{ ... }';\n    // };\n  }\n\n  get name() {\n    return `${this.params.type?.name} => ${this.rettype?.name}`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(valueType) {\n    return valueType instanceof FunctionType;\n  }\n}\n\nmodule.exports = {\n  FunctionType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/FunctionType.js?");

/***/ }),

/***/ "./src/visitors/types/NoneType.js":
/*!****************************************!*\
  !*** ./src/visitors/types/NoneType.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\n\nclass NoneType extends AnyType {\n  get name() {\n    return `None`;\n  }\n\n  isSupertypeOf(valueType) {\n    return false;\n  }\n\n  isSubtypeOf(valueType) {\n    return true;\n  }\n}\n\nmodule.exports = {\n  NoneType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/NoneType.js?");

/***/ }),

/***/ "./src/visitors/types/NumberType.js":
/*!******************************************!*\
  !*** ./src/visitors/types/NumberType.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\n\nclass NumberType extends AnyType {\n  get name() {\n    return `Number`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(valueType) {\n    return valueType instanceof this.constructor;\n  }\n\n  isSupertypeOf(valueType, visited = new Set(), depth = 0) {\n    if (depth > 2 && visited.has(this)) {\n      return false;\n    }\n\n    return this.isSubtypeOf(valueType, visited.add(this), depth + 1);\n  }\n\n  isSubtypeOf(valueType, visited = new Set(), depth = 0) {\n    if (depth > 2 && visited.has(this)) {\n      return false;\n    }\n\n    return valueType instanceof this.constructor || valueType.isSupertypeOf(this, visited.add(this), depth + 1);\n  }\n\n  //\n\n  typeForField(field) {\n    if (typeof field.value === 'number' && field.value === 0) {\n      return new NumberType();\n    }\n  }\n}\n\nmodule.exports = {\n  NumberType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/NumberType.js?");

/***/ }),

/***/ "./src/visitors/types/RangeType.js":
/*!*****************************************!*\
  !*** ./src/visitors/types/RangeType.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\nconst { NumberType } = __webpack_require__(/*! ./NumberType */ \"./src/visitors/types/NumberType.js\");\nconst { TupleType } = __webpack_require__(/*! ./TupleType */ \"./src/visitors/types/TupleType.js\");\nconst { UnionType } = __webpack_require__(/*! ./UnionType */ \"./src/visitors/types/UnionType.js\");\n\nclass RangeType extends AnyType {\n  constructor(elementType) {\n    super();\n\n    this.elementType = elementType;\n    this.params = {\n      matchType() { return true; }\n    };\n  }\n\n  get name() {\n    return `Range[${this.elementType?.name}]`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(type) {\n    return type instanceof this.constructor && this.elementType.includesType(type.elementType);\n  }\n\n  //\n\n  typeForField(field) {\n    if (typeof field.value === 'number') {\n      return new UnionType(this.elementType, new TupleType());\n    }\n  }\n\n  typeForMethod(method) {\n    return new NumberType();\n  }\n}\n\nmodule.exports = {\n  RangeType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/RangeType.js?");

/***/ }),

/***/ "./src/visitors/types/StringType.js":
/*!******************************************!*\
  !*** ./src/visitors/types/StringType.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\nconst { NumberType } = __webpack_require__(/*! ./NumberType */ \"./src/visitors/types/NumberType.js\");\n\nclass StringType extends AnyType {\n  get name() {\n    return `String`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(valueType) {\n    return valueType instanceof this.constructor;\n  }\n\n  isSupertypeOf(valueType, visited = new Set(), depth = 0) {\n    if (depth > 2 && visited.has(this)) {\n      return false;\n    }\n\n    return this.isSubtypeOf(valueType, visited.add(this), depth + 1);\n  }\n\n  isSubtypeOf(valueType, visited = new Set(), depth = 0) {\n    if (depth > 2 && visited.has(this)) {\n      return false;\n    }\n\n    return valueType instanceof this.constructor || valueType.isSupertypeOf(this, visited.add(this), depth + 1);\n  }\n\n  //\n\n  typeForField(field) {\n    if (String.prototype[field.name] === undefined) {\n      return null;\n    }\n\n    switch (field.name) {\n      case 'length': return new NumberType();\n    }\n  }\n}\n\nmodule.exports = {\n  StringType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/StringType.js?");

/***/ }),

/***/ "./src/visitors/types/TupleType.js":
/*!*****************************************!*\
  !*** ./src/visitors/types/TupleType.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\nconst { FunctionType } = __webpack_require__(/*! ./FunctionType */ \"./src/visitors/types/FunctionType.js\");\n\nclass TupleType extends AnyType {\n  constructor(types = [], fields = []) {\n    super();\n\n    this.types = types;\n    this.fields = fields;\n  }\n\n  //\n\n  get name() {\n    if (this.types.length === 0) {\n      return `Unit`;\n    }\n\n    return `(${this.types.map(type => type.name).join(', ')})`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(valueType) {\n    if (valueType instanceof TupleType && valueType.types.length === 0 && this.types.length === 0) {\n      return true;\n    }\n\n    return valueType instanceof TupleType && valueType.types.every((t, index) => t.includesType(this.types[index]));\n  }\n\n  //\n\n  typeForField(field) {\n    if (typeof field.value === 'number') {\n      if (field.value > this.types.length - 1) {\n        return null;\n      }\n\n      return this.types[field.value];\n    }\n\n    return this.types[this.fields.indexOf(field.name)];\n  }\n}\n\nmodule.exports = {\n  TupleType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/TupleType.js?");

/***/ }),

/***/ "./src/visitors/types/UnionType.js":
/*!*****************************************!*\
  !*** ./src/visitors/types/UnionType.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\n\nclass UnionType extends AnyType {\n  constructor(...types) {\n    super();\n\n    this.types = types;\n  }\n\n  //\n\n  get name() {\n    return `${this.types.map(type => type.name).join(' | ')}`;\n  }\n\n  escape() {\n    return this.name;\n  }\n\n  includesType(valueType) {\n    return this.types.some(type => type.includesType(valueType));\n  }\n\n  isSupertypeOf(valueType, visited = new Set(), depth = 0) {\n    if (depth > 2 && visited.has(this)) {\n      return false;\n    }\n\n    // TODO: visited.add(this?) or type?\n    return this.types.some(type => valueType.isSubtypeOf(type, visited.add(this), depth + 1));\n  }\n}\n\nmodule.exports = {\n  UnionType,\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/UnionType.js?");

/***/ }),

/***/ "./src/visitors/types/index.js":
/*!*************************************!*\
  !*** ./src/visitors/types/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { AnyType } = __webpack_require__(/*! ./AnyType */ \"./src/visitors/types/AnyType.js\");\nconst { NoneType } = __webpack_require__(/*! ./NoneType */ \"./src/visitors/types/NoneType.js\");\nconst { AstNodeType } = __webpack_require__(/*! ./AstNodeType */ \"./src/visitors/types/AstNodeType.js\");\nconst { BooleanType } = __webpack_require__(/*! ./BooleanType */ \"./src/visitors/types/BooleanType.js\");\nconst { NumberType } = __webpack_require__(/*! ./NumberType */ \"./src/visitors/types/NumberType.js\");\nconst { StringType } = __webpack_require__(/*! ./StringType */ \"./src/visitors/types/StringType.js\");\nconst { TupleType } = __webpack_require__(/*! ./TupleType */ \"./src/visitors/types/TupleType.js\");\nconst { ArrayType } = __webpack_require__(/*! ./ArrayType */ \"./src/visitors/types/ArrayType.js\");\nconst { RangeType } = __webpack_require__(/*! ./RangeType */ \"./src/visitors/types/RangeType.js\");\nconst { FunctionType } = __webpack_require__(/*! ./FunctionType */ \"./src/visitors/types/FunctionType.js\");\nconst { UnionType } = __webpack_require__(/*! ./UnionType */ \"./src/visitors/types/UnionType.js\");\n\n/*\n\ninterface FieldAccess {\n  typeForField(field: Number | String): Type\n}\n\n*/\n\nmodule.exports = {\n  AnyType: () => new AnyType(),\n  NoneType: () => new NoneType(),\n  AstNodeType: () => new AstNodeType(),\n  BooleanType: () => new BooleanType(),\n  NumberType: () => new NumberType(),\n  StringType: () => new StringType(),\n  TupleType: (types, fields) => new TupleType(types, fields),\n  ArrayType: (type) => new ArrayType(type),\n  RangeType: (type) => new RangeType(type),\n  FunctionType: (params, rettype, body, context) => new FunctionType(params, rettype, body, context),\n  UnionType: (...types) => new UnionType(...types),\n};\n\n\n//# sourceURL=webpack://kopi2/./src/visitors/types/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;