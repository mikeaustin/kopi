x = case 1, 2 of
  1, b => b
  _    => "error"
end

x = cond x > 1 ? 1 : x

x = cond
  x > 1 => 1
  x     => x
end

x = case bar
  Point (x, y)     => "Point"
  Circle (x, y, r) => "Circle"
end


wordcount string = string | split " " | reduce (counts, word) => (
  counts | update word, (x = 0) => count + 1
), {:}

match parseYesNo(response)
    case b is Bool       then "Got good answer"
    case e is ParseError then "Bad input"
end

match foobar
  (x, y): Point => "Point"
end


employeeNames | sort (a, b) => a > b | map (name) => do
  name | split "," | map (name) => (name | strip) | reverse | join " "
end

employeeNames = ['a,b', 'c,d']

employeeNames.sort((a, b) => a > b).map(name => {
  return name.split(',').map(name => name.trim()).reverse().join(' ')
})


(x, k => (x, k => k x + 1) x + x, k) 5, (x => x)

map = xs, f => f 0
map 1..5, (x => map x..5, (y => x + y))

print 1 + 2, 2 + 3, 1..5 + 2

((() 5) 5) ++ "abc"

range = 1..10
range.from, range.to


1..5 | reduce '*, 1

[1, 2, 3] | reduce 'toString, 1

'(x + x)

x = 0
f = () => update 'x z => z + 1
f ()
x

factorial factorial, n = match n (
  0 => 1
  n => n * (factorial factorial, n - 1)
)

factorial factorial, 5
