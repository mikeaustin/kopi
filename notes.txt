x = case 1, 2 of
  1, b => b
  _    => "error"
end

x = cond x > 1 ? 1 : x

x = cond
  x > 1 => 1
  x     => x
end

x = case bar
  Point (x, y)     => "Point"
  Circle (x, y, r) => "Circle"
end


wordcount string = string | split " " | reduce (counts, word) => (
  counts | update word, (x = 0) => count + 1
), {:}

match parseYesNo(response)
    case b is Bool       then "Got good answer"
    case e is ParseError then "Bad input"
end

match foobar
  (x, y): Point => "Point"
end


employeeNames | sort (a, b) => a > b | map (name) => do
  name | split "," | map (name) => (name | strip) | reverse | join " "
end

employeeNames = ['a,b', 'c,d']

employeeNames.sort((a, b) => a > b).map(name => {
  return name.split(',').map(name => name.trim()).reverse().join(' ')
})


(x, k => (x, k => k x + 1) x + x, k) 5, (x => x)

map (i => map (j => i + j) i+1..j) 1..5

print 1 + 2, 2 + 3, 1..5 + 2

((() 5) 5) ++ "abc"

range = 1..10
range.from, range.to


1..5 | reduce '*, 1

[1, 2, 3] | reduce 'toString, 1

'(x + x)

x = 0
f = () => update 'x z => z + 1
f ()
x

factorial factorial, n = match n (
  0 => 1
  n => n * (factorial factorial, n - 1)
)

factorial factorial, 5

match 0 (
  0 => "zero"
  x => x
)

map (x => x * x) 1..5

map 'toString 1..5

map '(+ 1) 1..5

f n = 1..n  # const f = n => range(1, n)

swap a, b = b, a

type 'Range (1, 10)

R = Range

R (1, 10)

Point = (x: Number, y: Number)

(1, y: 2)

1..5 | map '(+ 1)

(if (x * 5) then (0 else 1))
