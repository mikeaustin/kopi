print ""
print "== interpret ====================================="
print ""

incIndex = data => (index: data.index + 1)
setIndex = index => data => (index: index)

evaluate = (statement) => match statement (
  line, "PRINT", value => {
    print $ value
    incIndex
  }
  line, "GOTO", goto => {
    setIndex ((Number goto) / 10 - 1)
  }
  line, command => {
    print $ "*** UNKNOWN COMMAND '" ++ command ++ "' ON LINE " ++ line
    incIndex
  }
)

print $ ['(* 2), '(toFixed 2)] | _reduce 5 $ (x, f) => f x

pipe = fs => x => fs | _reduce x $ (x, f) => f x

print $ pipe ['(* 2), '(toFixed 2)] 5

interpret = (source) => {
  program = source | trim | split (char 10) | _map (
    (line) => tuple $ (line | trim) | split " "
  )

  # lineNumbers = source | trim | split (char 10) | _reduce {:} $ (numbers, line) => (
  #   numbers | set number index
  # )

  print program

  loop = (data) => {
    match (data.index == '_length program) (
      true => ()
      _    => {
        reducer = evaluate program.(data.index)
        loop (reducer data)
      }
    )
  }

  loop (index: 0)

  # program | _map (statement) => evaluate statement
}

source = "
  10 PRINT 'HELLO'
  20 GOTO 40
  30 PRINT 'NOPE'
  40 PRINT 'WORLD'
"

interpret source
