fold (a, x => x * x), 1..5
sort "julie" ++ "moronuki"
xs | reduce 0 sum, x => sum + x


loop (exit, a = 1) => {
  print "hello"

  match a (
    10 => exit ()
    n  => n + 1
  )
}


match n (
  0 => 1
  n => n * n
  n @ even => n * n
)

1..10 | map (n @ even n) => n * n

1..10 | map (n) @ even n => n * n

1..10 | map (n @ n > x) => n * n


scheme cond case


grayscale = color => match color (
  RGB (r, g, b) => (r + g + b) / 3
  HSL (h, s, l) => l
)


[1 + 1, "a" ++ "b", even 1, x => x]

[
  even $ 1,
  1 | toString,
  "a" ++ "b",
  even 1,
  x => x,
  (1, 2),
  1 + 1,
  1..5
]



spawn adds a new listener
  if data arives, store it and block (return promise)
  when yield is called, get data and resolve promise

put a promise in coroutineBufferMap?




const coroutineBufferMap = {};

class Deferred extends Promise {

}

  coroutineEventEmitter.on(coroutineId, (event) => {
    coroutineBufferMap[coroutineId] = [event.data,];
  });
  