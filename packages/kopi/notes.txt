
wordcount string = string | split " " | reduce (counts, word) => (
  counts | update word, (x = 0) => count + 1
), {:}

match foobar
  (x, y): Point => "Point"
  Point (x, y)  => "Point"
end

employeeNames = ['a,b', 'c,d']
employeeNames | sort (a, b) => a > b | map (name) => do
  name | split "," | map (name) => (name | strip) | reverse | join " "
end


1..10 | map (n @ even n) => n * n

1..10 | map (n) @ even n => n * n


grayscale = color => match color (
  RGB (r, g, b) => (r + g + b) / 3
  HSL (h, s, l) => l
)


[1 + 1, "a" ++ "b", even 1, x => x]

[
  even $ 1,
  1 | toString,
  "a" ++ "b",
  even 1,
  x => x,
  (1, 2),
  1 + 1,
  1..5
]


print $ 1..10 | map (even n) => n * n

print $ 1..10 | map (n) @ even n => n * n

x = z > 1 ? 1 : x

x = if z > 1 then 1 else x

x = match x (
  x @ x > 1 => 1
)

x = match () (
  _ @ x > y => 0
  _         => 1
)

x = match () (
  @ x > y => 0
  @       => 1
)

x = match () _ [x > y] => 0, _ [] => 1


match age (
     1..18  => "child"
    19..100 => "adult"
)


Color = RGB (r: Int, g: Int, b: Int)

Color.RGB (100, 100, 255)


Point = T => type (x: T, y: T)


Move print to println?


File.read "notes.txt"

Net.fetch "https://google.com"



$
==
++
+ | -
* | /
apply
!

Currying requires left-associative application

1, 2 + 1    (1, (2 + 1))

f x         (f x)

f x + f y   (f x) + (f y)



operators
apply
tuple


[ even $ 1,  1 | toString,  "a" ++ "b",  even 1,  x => x,  (1, 2),  1 + 1,  1..5 ]


|       PipeExpression
++      ConcatinationExpression
x => x  FunctionExpression
1, 2    TupleExpression
[1, 2]  ArrayExpression
{1: 2}  DictExpression
1 == 1  EqualityExpression
1 + 1   AddExpression
1 * 1   MultiplyExpression
{}      BlockExpression
1..5    RangeExpression
v.x     MemberExpression
