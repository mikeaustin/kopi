:html, :body, :text = import "test/html.kopi"

html:, body:, text: = import "test/html.kopi"


wordcount string = string | split " " | reduce (counts, word) => (
  counts | update word, (x = 0) => count + 1
), {:}

match foobar
  (x, y): Point => "Point"
  Point (x, y)  => "Point"
end

employeeNames = ['a,b', 'c,d']
employeeNames | sort (a, b) => a > b | map (name) => do
  name | split "," | map (name) => (name | strip) | reverse | join " "
end

Point = (x: Number, y: Number)


1..10 | map (n @ even n) => n * n

1..10 | map (n) @ even n => n * n


grayscale = color => match color (
  RGB (r, g, b) => (r + g + b) / 3
  HSL (h, s, l) => l
)


[1 + 1, "a" ++ "b", even 1, x => x]

[
  even $ 1,
  1 | toString,
  "a" ++ "b",
  even 1,
  x => x,
  (1, 2),
  1 + 1,
  1..5
]


even = '(% 2 == 0)


print (1, 2, z: 3)
print (1, y: 2, z: 3)
print (x: 1, y: 2, z: 3)
print (1, y: 2, 3)


print $ 1..10 | map (even n) => n * n

print $ 1..10 | map (n) @ even n => n * n

x = z > 1 ? 1 : x

x = if z > 1 then 1 else x

x = match x (
  x @ x > 1 => 1
)

x = match () (
  _ @ x > y => 0
  _         => 1
)

x = match () (
  @ x > y => 0
  @       => 1
)

x = match () _ [x > y] => 0, _ [] => 1


match age (
     1..18  => "child"
    19..100 => "adult"
)


type aliases?

Person = type (name: String, age: Int)

Person = (name: String, age: Int)

person = Person (name: "Joe", age: 30)

Person (:name:, :age)  => "Hello, {name}."


Color = RGB (r: Int, g: Int, b: Int)

Color.RGB (100, 100, 255)


Point<T> = Point<T> (x: T, y: T)

Point = T => type (x: T, y: T)


Move read to fetch?
print to println?


File.read "notes.txt"

Net.fetch "https://google.com"
